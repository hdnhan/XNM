 
D:\Study\Projects\XNM\code>XNM3.edp
 
D:\Study\Projects\XNM\code>-- FreeFem++ v  3.610001 (date jeu. 12 juil. 2018 15:05:23)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue 
    1 : load "medit"(load: loadLibary C:\Progra3m Files (x86)\FreeFem++\\.\medit = 0)
    2 :
    3 : string path = "data/";
    4 : int nthfile = 3;
    5 : string filemesh = "Th" + nthfile;
    6 : mesh Th = readmesh(path + filemesh + ".msh");
    7 :
    8 : int[int] NoVMesh = [515, 1802, 6718];
    9 : real[int, int] hz(NoVMesh[nthfile - 1], 3);
   10 : ifstream filemeshZ(path + filemesh + "CoZ.txt");
   11 : filemeshZ >> hz;
   12 :
   13 : real[string] mapz;
   14 : for (int i = 0; i < hz.n; i++){
   15 :     mapz[string(hz(i, 0)) + " " + string(hz(i, 1))] = hz(i, 2);
   16 : }
   17 :
   18 : func real[int] FillZ(real[int] mat){
   19 :     for (int i = 0; i < Th.nv; i++){
   20 :         mat(i) = mapz[string(Th(i).x) + " " + string(Th(i).y)];
   21 :     }
   22 :     return mat;
   23 : }
   24 :
   25 : real[int, int] data(503, 4);
   26 : ifstream filedata(path + "SLMIKE21-3.txt");
   27 : filedata >> data;
   28 :
   29 : func real[int] InterpolationData(real t){
   30 :     // t: time (unit: second)
   31 :     real T = 3600;
   32 :     int n = t /  T;
   33 :     real delt = t / T - n;
   34 :     real[int] res(4);
   35 :     res(0) = data(n, 0) * delt + data(n + 1, 0) * (1 - delt);
   36 :     res(1) = data(n, 1) * delt + data(n + 1, 1) * (1 - delt);
   37 :     res(2) = data(n, 2) * delt + data(n + 1, 2) * (1 - delt);
   38 :     res(3) = data(n, 3) * delt + data(n + 1, 3) * (1 - delt);
   39 :     return res;
   40 : }
   41 :
   42 : real dt = 1e-2, nu = 2.67 * 1e-4, g = 9.81, rho = 1000, n = 0.025, T = 9999999;
   43 : real tau =  g * n * n;
   44 : real eps = 0.05;
   45 :
   46 : macro Grad(u) [dx(u), dy(u)]  )   [dx(u), dy(u)] //
   47 : macro Grad1(ux, uy) [dx(ux), dy(ux), dx(uy), dy(uy)]  )   [dx(ux), dy(ux), dx(uy),3 dy(uy)] //
   48 : macro Grad2(ux, uy) [[dx(ux), dy(ux)], [dx(uy), dy(uy)]]  )   [[dx(ux), dy(ux)], [3dx(uy), dy(uy)]] //
   49 : macro Div(ux, uy) (dx(ux) + dy(uy))  )   (dx(ux) + dy(uy)) //
   50 :
   51 :
   52 : fespace Xh(Th, P1);
   53 : fespace Hh(Th, P1dc);
   54 : Xh zh; zh[] = FillZ(zh[]);
   55 : Hh H, phi, Hold = 9 - zh;
   56 : Xh ux = 0.5, uy = 0.0;
   57 :
   58 : int cnt = 0;
   59 : string foldername = "result3/";
   60 :
   61 : for(real t = dt; t <= dt; t += dt){
   62 :     cout << "t: " << t << endl;
   63 :     real[int] BoundData = InterpolationData(t);
   64 :     Xh etaUB = BoundData(1);
   65 :     Xh etaUB1 = BoundData(2);
   66 :     Xh etaUB2 = BoundData(3);
   67 :
   68 :     real al = 0.5;
   69 :     macro n() (N.x * ux + N.y * uy)  (N.x * ux + N.y * uy) //
   70 :     solve TransportEquation(H, phi) =
   71 :         int2d(Th)((H/dt + ux * dx(H) + uy * dy(H) + H * Div(ux, uy)     (dx(ux) +
3dy( uy)) ) * phi)
   72 :         + intalledges(Th)((1 - nTonEdge) * phi * (al * abs(n         (N.x * ux + N3.y * uy) ) - n         (N.x * ux + N.y * uy) /2) *  jump(H))
   73 :         - int1d(Th, 2)((n         (N.x * ux + N.y * uy)  < 0) * abs(n         (N.x3 * ux + N.y * uy) ) * H * phi)
   74 :         - int2d(Th)(Hold * phi / dt)
   75 :         + int1d(Th, 2)((n         (N.x * ux + N.y * uy)  < 0) * abs(n         (N.x3 * ux + N.y * uy) ) * (etaUB - zh) * phi);
   76 :
   77 :     mesh Thwet = trunc(Th, H >= eps);
   78 :
   79 :     ofstream wf(foldername + "Thwet.msh");
   80 :     wf.fixed;
   81 :     wf << Thwet.nv << " " << Thwet.nt << " " << Thwet.nbe << endl;
   82 :
   83 :     for(int i = 0; i < Thwet.nv; i++){
   84 :         int check = 0;
   85 :         for (int j = 0; j < Thwet.nbe; j++){
   86 :             if ((i == Thwet.be(j)[0] || i == Thwet.be(j)[1]) && (Thwet(i).label ==3 0)){
   87 :                 check = 1;
   88 :                 break;
   89 :             }
   90 :         }
   91 :         if (check == 1){
   92 :             wf << Thwet(i).x << " " << Thwet(i).y << " " << 1 << endl;
   93 :         } else {
   94 :             wf << Thwet(i).x << " " << Thwet(i).y << " " << Thwet(i).label << endl3;
   95 :         }
   96 :     }
   97 :
   98 :     for (int i = 0; i < Thwet.nt; i++){
   99 :         wf << Thwet[i][0] + 1 << " " << Thwet[i][1]  + 1 << " " << Thwet[i][2]  +
31 << " " << Thwet[i].label << endl;
  100 :     }
  101 :
  102 :     for(int i = 0; i < Thwet.nbe; i++){
  103 :         wf << Thwet.be(i)[0] + 1 << " " << Thwet.be(i)[1] + 1 << " " << Thwet.be(i3).label <<  endl;
  104 :     }
  105 :
  106 :     wf.flush;
  107 :
  108 :     Thwet = readmesh(foldername + "Thwet.msh");
  109 :     // for(int i = 0; i < Thwet.nv; i++){
  110 :     //     int it = Th(Thwet(i).x, Thwet(i).y).nuTriangle;
  111 :     //     for (int j = 0; j < 3; j++){
  112 :     //         if (Thwet(i).x == Th[it][j].x && Thwet(i).y == Th[it][j].y){
  113 :     //             cout << "i = " << i << ": " << Th[it][j] << endl;
  114 :     //             break;
  115 :     //         }
  116 :     //     }
  117 :     // }
  118 :
  119 :     fespace Xhwet(Thwet, P1);
  120 :     Xhwet uwx, uwy, vx, vy;
  121 :     Xhwet uxold = 0.5, uyold = 0;
  122 :     if (t > dt){
  123 :         for(int i = 0; i < Thwet.nt; i++){
  124 :             int it = Th(Thwet(i).x, Thwet(i).y).nuTriangle;
  125 :             for (int j = 0; j < 3; j++){
  126 :             if (Thwet(i).x == Th[it][j].x && Thwet(i).y == Th[it][j].y){
  127 :                 uxold[][i] = ux[][Th[it][j]];
  128 :                 uyold[][i] = uy[][Th[it][j]];
  129 :                 break;
  130 :             }
  131 :         }
  132 :     }
  133 :     ux = 0; uy = 0; // reset
  134 :
  135 :     Xhwet eta = H + zh;
  136 :     Xhwet uUB = BoundData(0);
  137 :     solve NavierStokes([uwx, uwy], [vx, vy], solver = Crout) =
  138 :         int2d(Thwet)((uwx * vx + uwy * vy) / dt)
  139 :         - int2d(Thwet)(
  140 :               convect([uxold, uyold], -dt, uxold) * vx / dt
  141 :             + convect([uxold, uyold], -dt, uyold) * vy / dt
  142 :         )
  143 :         + int2d(Thwet)(g * Grad(eta)    [dx(eta), dy(eta)] ' * [vx, vy])
  144 :         // - int2d(Thwet)(g * eta * Div(vx, vy))
  145 :         - int2d(Thwet)(nu / H * [vx, vy]' * Grad2(uwx, uwy)      [[dx(uwx), dy(uwx3)], [dx( uwy), dy( uwy)]]  * Grad(H)    [dx(H), dy(H)]  - nu * Grad1(uwx, uwy)      [dx(uw3x), dy(uwx), dx( uwy), dy( uwy)] ' * Grad1(vx, vy)      [dx(vx), dy(vx), dx( vy), dy( vy)]3 )
  146 :         + int2d(Thwet)((tau * 1/H^(4/3) * (uxold * uxold + uyold * uyold)^(0.5)) *3 (uwx * vx + uwy * vy))
  147 :         + on(2, uwx = uUB, uwy = 0) + on(1, uwx = 0, uwy = 0);
  148 :
  149 :
  150 :     for(int i = 0; i < Thwet.nt; i++){
  151 :         int it = Th(Thwet(i).x, Thwet(i).y).nuTriangle;
  152 :         for (int j = 0; j < 3; j++){
  153 :             if (Thwet(i).x == Th[it][j].x && Thwet(i).y == Th[it][j].y){
  154 :                 ux[][Th[it][j]] = uwx[][i];
  155 :                 uy[][Th[it][j]] = uwy[][i];
  156 :                 break;
  157 :             }
  158 :         }
  159 :     }
  160 :     Hold = H;
  161 :     // plot(H, fill = 1, value = 1);
  162 :     plot([ux, uy], fill = 1, value = 1);
  163 :     // medit("Th", Th, [ux, uy]);
  164 :
  165 :     savesol(foldername + "ThH." + string(cnt) + ".sol", Th, H);
  166 :         savemesh(Th, foldername + "ThH." + string(cnt)+".mesh");
  167 :     savesol(foldername + "ThU." + string(cnt) + ".sol", Th, [ux, uy]);
  168 :         savemesh(Th, foldername + "ThU." + string(cnt)+".mesh");
  169 :     cnt += 1;
  170 : }
  171 : // savemesh(Th, foldername + "ThU.mesh");ÿ
 Error line number 171, in file -- unkown --, before  token
syntax error
  current line = 170
Compile error : syntax error
        line number :171,
error Compile error : syntax error
        line number :171,
 code = 1 mpirank: 0
 try getConsole D:\Study\Projects\XNM\code\XNM3.edp
