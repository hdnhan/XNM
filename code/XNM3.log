 
D:\Study\Projects\XNM\code>XNM3.edp
 
D:\Study\Projects\XNM\code>-- FreeFem++ v  3.610001 (date jeu. 12 juil. 2018 15:05:23)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : load "medit"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\medit = 0)
    2 :
    3 : string path = "data/";
    4 : int nthfile = 3;
    5 : string filemesh = "Th" + nthfile;
    6 : mesh Th = readmesh(path + filemesh + ".msh");
    7 :
    8 : int[int] NoVMesh = [515, 1802, 6718];
    9 : real[int, int] hz(NoVMesh[nthfile - 1], 3);
   10 : ifstream filemeshZ(path + filemesh + "CoZ.txt");
   11 : filemeshZ >> hz;
   12 :
   13 : real[string] mapz;
   14 : for (int i = 0; i < hz.n; i++){
   15 :     mapz[string(hz(i, 0)) + " " + string(hz(i, 1))] = hz(i, 2);
   16 : }
   17 :
   18 : func real[int] FillZ(real[int] mat){
   19 :     for (int i = 0; i < Th.nv; i++){
   20 :         mat(i) = mapz[string(Th(i).x) + " " + string(Th(i).y)];
   21 :     }
   22 :     return mat;
   23 : }
   24 :
   25 : real[int, int] data(503, 4);
   26 : ifstream filedata(path + "SLMIKE21-3.txt");
   27 : filedata >> data;
   28 :
   29 : func real[int] InterpolationData(real t){
   30 :     // t: time (unit: second)
   31 :     real T = 3600;
   32 :     int n = t /  T;
   33 :     real delt = t / T - n;
   34 :     real[int] res(4);
   35 :     res(0) = data(n + 1, 0) * delt + data(n, 0) * (1 - delt);
   36 :     res(1) = data(n + 1, 1) * delt + data(n, 1) * (1 - delt);
   37 :     res(2) = data(n + 1, 2) * delt + data(n, 2) * (1 - delt);
   38 :     res(3) = data(n + 1, 3) * delt + data(n, 3) * (1 - delt);
   39 :     return res;
   40 : }
   41 :
   42 : real dt = 1e-2, nu = 2.67 * 1e-4, g = 9.81, rho = 1000, n = 0.025, T = 9999999;
   43 : real tau =  g * n * n;
   44 : real eps = 0.05;
   45 :
   46 : macro Grad(u) [dx(u), dy(u)]  )   [dx(u), dy(u)] //
   47 : macro Grad1(ux, uy) [dx(ux), dy(ux), dx(uy), dy(uy)]  )   [dx(ux), dy(ux), dx(uy), dy(uy)] //
   48 : macro Grad2(ux, uy) [[dx(ux), dy(ux)], [dx(uy), dy(uy)]]  )   [[dx(ux), dy(ux)], [dx(uy), dy(uy)]] //
   49 : macro Div(ux, uy) (dx(ux) + dy(uy))  )   (dx(ux) + dy(uy)) //
   50 :
   51 :
   52 : fespace Xh(Th, P1);
   53 : fespace Hh(Th, P1dc);
   54 : Xh zh; zh[] = FillZ(zh[]);
   55 : Hh H, phi, Hold = 9 - zh;
   56 : Xh ux = 0.5, uy = 0.0;
   57 : Xh vdof;
   58 : vdof[] = 0 : Xh.ndof-1;
   59 : int cnt = 0;
   60 : string foldername = "result3/";
   61 :
   62 : for(real t = dt; t <= T; t += dt){
   63 :     cout << "t: " << t << endl;
   64 :     real[int] BoundData = InterpolationData(t);
   65 :     real etaUB = BoundData(1);
   66 :     // Xh etaUB1 = BoundData(2);
   67 :     // Xh etaUB2 = BoundData(3);
   68 :
   69 :     real al = 0.5;
   70 :     macro n() (N.x * ux + N.y * uy)  (N.x * ux + N.y * uy) //
   71 :     solve TransportEquation(H, phi) =
   72 :         int2d(Th)((H/dt + ux * dx(H) + uy * dy(H) + H * Div(ux, uy)     (dx(ux) + dy( uy)) ) * phi)
   73 :         + intalledges(Th)((1 - nTonEdge) * phi * (al * abs(n         (N.x * ux + N.y * uy) ) - n         (N.x * ux + N.y * uy) /2) *  jump(H))
   74 :         - int1d(Th, 2)((n         (N.x * ux + N.y * uy)  < 0) * abs(n         (N.x * ux + N.y * uy) ) * H * phi)
   75 :         - int2d(Th)(Hold * phi / dt)
   76 :         + int1d(Th, 2)((n         (N.x * ux + N.y * uy)  < 0) * abs(n         (N.x * ux + N.y * uy) ) * (etaUB - zh) * phi);
   77 :
   78 :     mesh Thwet = trunc(Th, H >= eps);
   79 :
   80 :     ofstream wf(foldername + "Thwet.msh");
   81 :     wf.fixed;
   82 :     wf << Thwet.nv << " " << Thwet.nt << " " << Thwet.nbe << endl;
   83 :
   84 :     for(int i = 0; i < Thwet.nv; i++){
   85 :         int check = 0;
   86 :         for (int j = 0; j < Thwet.nbe; j++){
   87 :             if ((i == Thwet.be(j)[0] || i == Thwet.be(j)[1]) && (Thwet(i).label == 0)){
   88 :                 check = 1;
   89 :                 break;
   90 :             }
   91 :         }
   92 :         if (check == 1){
   93 :             wf << Thwet(i).x << " " << Thwet(i).y << " " << 1 << endl;
   94 :         } else {
   95 :             wf << Thwet(i).x << " " << Thwet(i).y << " " << Thwet(i).label << endl;
   96 :         }
   97 :     }
   98 :
   99 :     for (int i = 0; i < Thwet.nt; i++){
  100 :         wf << Thwet[i][0] + 1 << " " << Thwet[i][1]  + 1 << " " << Thwet[i][2]  + 1 << " " << Thwet[i].label << endl;
  101 :     }
  102 :
  103 :     for(int i = 0; i < Thwet.nbe; i++){
  104 :         wf << Thwet.be(i)[0] + 1 << " " << Thwet.be(i)[1] + 1 << " " << Thwet.be(i).label <<  endl;
  105 :     }
  106 :
  107 :     wf.flush;
  108 :
  109 :     Thwet = readmesh(foldername + "Thwet.msh");
  110 :     // medit("Thwet", Thwet);
  111 :
  112 :     fespace Xhwet(Thwet, P1);
  113 :     Xhwet uwx, uwy, vx, vy;
  114 :     Xhwet uxold, uyold;
  115 :     Xhwet etawet, Hwet;
  116 :
  117 :     for(int i = 0; i < Thwet.nv; i++){
  118 :         uxold[][i] = ux(Thwet(i).x, Thwet(i).y);
  119 :         uyold[][i] = uy(Thwet(i).x, Thwet(i).y);
  120 :         Hwet[][i] = H(Thwet(i).x, Thwet(i).y);
  121 :         etawet[][i] = H(Thwet(i).x, Thwet(i).y) + zh(Thwet(i).x, Thwet(i).y);
  122 :
  123 :
  124 :     //     // cout << "i = " << i + 2 << ": ";
  125 :     //     int it = Th(Thwet(i).x, Thwet(i).y).nuTriangle;
  126 :     //     for (int j = 0; j < 3; j++){
  127 :     //         if (Thwet(i).x == Th[it][j].x && Thwet(i).y == Th[it][j].y){
  128 :     //             // cout.fixed << Th[it][j] + 2 << " => " << Th[it][j].x << " " << Th[it][j].y << endl;
  129 :     //             uxold[][i] = ux[][Th[it][j]];
  130 :     //             uyold[][i] = uy[][Th[it][j]];
  131 :     //             Hwet[][i] = H[][Th[it][j]];
  132 :     //             etawet[][i] = H[][Th[it][j]] + zh[][Th[it][j]];
  133 :     //             break;
  134 :     //         }
  135 :     //     }
  136 :     // }
  137 :     // cout << uxold[] << endl;
  138 :     ux = 0; uy = 0; // reset
  139 :
  140 :     // Xhwet eta = H + zh;
  141 :     real uUB = BoundData(0);
  142 :     // cout << uUB[] << endl;
  143 :     solve NavierStokes([uwx, uwy], [vx, vy], solver = Crout) =
  144 :         int2d(Thwet)((uwx * vx + uwy * vy) / dt)
  145 :         - int2d(Thwet)(
  146 :               convect([uxold, uyold], -dt, uxold) * vx / dt
  147 :             + convect([uxold, uyold], -dt, uyold) * vy / dt
  148 :         )
  149 :         + int2d(Thwet)(g * Grad(etawet)    [dx(etawet), dy(etawet)] ' * [vx, vy])
  150 :         // - int2d(Thwet)(g * eta * Div(vx, vy))
  151 :         - int2d(Thwet)(nu / Hwet * [vx, vy]' * Grad2(uwx, uwy)      [[dx(uwx), dy(uwx)], [dx( uwy), dy( uwy)]]  * Grad(Hwet)    [dx(Hwet), dy(Hwet)]  -
nu * Grad1(uwx, uwy)      [dx(uwx), dy(uwx), dx( uwy), dy( uwy)] ' * Grad1(vx, vy)      [dx(vx), dy(vx), dx( vy), dy( vy)] )
  152 :         + int2d(Thwet)((tau * 1/Hwet^(4/3) * (uxold * uxold + uyold * uyold)^(0.5)) * (uwx * vx + uwy * vy))
  153 :         + on(2, uwx = uUB, uwy = 0) + on(1, uwx = 0, uwy = 0);
  154 :
  155 :
  156 :     for(int i = 0; i < Thwet.nv; i++){
  157 :         ux[][vdof(Thwet(i).x, Thwet(i).y)] = uwx[][i];
  158 :         uy[][vdof(Thwet(i).x, Thwet(i).y)] = uwy[][i];
  159 :         // ux(Thwet(i).x, Thwet(i).y) = uwx[][i];
  160 :         // uy(Thwet(i).x, Thwet(i).y) = uwy[][i];
  161 :         // int it = Th(Thwet(i).x, Thwet(i).y).nuTriangle;
  162 :         // for (int j = 0; j < 3; j++){
  163 :         //     if (Thwet(i).x == Th[it][j].x && Thwet(i).y == Th[it][j].y){
  164 :         //         ux[][Th[it][j]] = uwx[][i];
  165 :         //         uy[][Th[it][j]] = uwy[][i];
  166 :         //         break;
  167 :         //     }
  168 :         // }
  169 :     }
  170 :     Hold = H;
  171 :     // plot(H, fill = 1, value = 1);
  172 :     plot([ux, uy], fill = 1, value = 1);
  173 :     // medit("Th", Th, [ux, uy]);
  174 :
  175 :     savesol(foldername + "ThH." + string(cnt) + ".sol", Th, H);
  176 :         savemesh(Th, foldername + "ThH." + string(cnt)+".mesh");
  177 :     savesol(foldername + "ThU." + string(cnt) + ".sol", Th, [ux, uy]);
  178 :         savemesh(Th, foldername + "ThU." + string(cnt)+".mesh");
  179 :     cnt += 1;
  180 : }
  181 : savemesh(Th, foldername + "ThH.mesh");
  182 : savemesh(Th, foldername + "ThU.mesh");
 Error line number 182, in file -- unkown --, before  token
syntax error
  current line = 182
Compile error : syntax error
        line number :182,
error Compile error : syntax error
        line number :182,
 code = 1 mpirank: 0
 try getConsole D:\Study\Projects\XNM\code\XNM3.edp
