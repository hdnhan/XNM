-- FreeFem++ v  3.610001 (date jeu. 12 juil. 2018 15:05:23)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : load "medit"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\medit = 0)
    2 :
    3 : string path = "data/";
    4 : int nthfile = 3;
    5 : string filemesh = "Th" + nthfile;
    6 : mesh Th = readmesh(path + filemesh + ".msh");
    7 :
    8 : int[int] NoVMesh = [515, 1802, 6718];
    9 : real[int, int] hz(NoVMesh[nthfile - 1], 3);
   10 : ifstream filemeshZ(path + filemesh + "CoZ.txt");
   11 : filemeshZ >> hz;
   12 :
   13 : real[string] mapz;
   14 : for (int i = 0; i < hz.n; i++){
   15 :     mapz[string(hz(i, 0)) + " " + string(hz(i, 1))] = hz(i, 2);
   16 : }
   17 :
   18 : func real[int] FillZ(real[int] mat){
   19 :     for (int i = 0; i < Th.nv; i++){
   20 :         mat(i) = mapz[string(Th(i).x) + " " + string(Th(i).y)];
   21 :     }
   22 :     return mat;
   23 : }
   24 :
   25 : real[int, int] data(503, 4);
   26 : ifstream filedata(path + "SLMIKE21-3.txt");
   27 : filedata >> data;
   28 :
   29 : func real[int] InterpolationData(real t){
   30 :     // t: time (unit: second)
   31 :     real T = 3600;
   32 :     int n = t /  T;
   33 :     real delt = t / T - n;
   34 :     real[int] res(4);
   35 :     res(0) = data(n + 1, 0) * delt + data(n, 0) * (1 - delt);
   36 :     res(1) = data(n + 1, 1) * delt + data(n, 1) * (1 - delt);
   37 :     res(2) = data(n + 1, 2) * delt + data(n, 2) * (1 - delt);
   38 :     res(3) = data(n + 1, 3) * delt + data(n, 3) * (1 - delt);
   39 :     return res;
   40 : }
   41 :
   42 : real dt = 1e-2, nu = 2.67 * 1e-4, g = 9.81, rho = 1000, n = 0.025, T = 9999999;
   43 : real tau =  g * n * n;
   44 : real eps = 0.05;
   45 :
   46 : macro Grad(u) [dx(u), dy(u)]  )   [dx(u), dy(u)] //
   47 : macro Grad1(ux, uy) [dx(ux), dy(ux), dx(uy), dy(uy)]  )   [dx(ux), dy(ux), dx(uy), dy(uy)] //
   48 : macro Grad2(ux, uy) [[dx(ux), dy(ux)], [dx(uy), dy(uy)]]  )   [[dx(ux), dy(ux)], [dx(uy), dy(uy)]] //
   49 : macro Div(ux, uy) (dx(ux) + dy(uy))  )   (dx(ux) + dy(uy)) //
   50 :
   51 :
   52 : fespace Xh(Th, P1);
   53 : fespace Hh(Th, P1dc);
   54 : Xh zh; zh[] = FillZ(zh[]);
   55 : Hh H, phi, Hold = 9 - zh;
   56 : Xh ux = 0.5, uy = 0.0;
   57 :
   58 : int cnt = 0;
   59 : string foldername = "result3/";
   60 :
   61 : for(real t = dt; t <= T; t += dt){
   62 :     cout << "t: " << t << endl;
   63 :     real[int] BoundData = InterpolationData(t);
   64 :     real etaUB = BoundData(1);
   65 :     // Xh etaUB1 = BoundData(2);
   66 :     // Xh etaUB2 = BoundData(3);
   67 :
   68 :     real al = 0.5;
   69 :     macro n() (N.x * ux + N.y * uy)  (N.x * ux + N.y * uy) //
   70 :     solve TransportEquation(H, phi) =
   71 :         int2d(Th)((H/dt + ux * dx(H) + uy * dy(H) + H * Div(ux, uy)     (dx(ux) + dy( uy)) ) * phi)
   72 :         + intalledges(Th)((1 - nTonEdge) * phi * (al * abs(n         (N.x * ux + N.y * uy) ) - n         (N.x *
È™ßt±Ë?ux + N.y * uy) /2) *  jump(H))
   73 :         - int1d(Th, 2)((n         (N.x * ux + N.y * uy)  < 0) * abs(n         (N.x * ux + N.y * uy) ) * H * phi)È™ßt±Ë? 
   74 :         - int2d(Th)(Hold * phi / dt)
   75 :         + int1d(Th, 2)((n         (N.x * ux + N.y * uy)  < 0) * abs(n         (N.x * ux + N.y * uy) ) * (etaUB -È™ßt±Ë? zh) * phi);
   76 :
   77 :     mesh Thwet = trunc(Th, H >= eps);
   78 :
   79 :     ofstream wf(foldername + "Thwet.msh");
   80 :     wf.fixed;
   81 :     wf << Thwet.nv << " " << Thwet.nt << " " << Thwet.nbe << endl;
   82 :
   83 :     for(int i = 0; i < Thwet.nv; i++){
   84 :         int check = 0;
   85 :         for (int j = 0; j < Thwet.nbe; j++){
   86 :             if ((i == Thwet.be(j)[0] || i == Thwet.be(j)[1]) && (Thwet(i).label == 0)){
   87 :                 check = 1;
   88 :                 break;
   89 :             }
   90 :         }
   91 :         if (check == 1){
   92 :             wf << Thwet(i).x << " " << Thwet(i).y << " " << 1 << endl;
   93 :         } else {
   94 :             wf << Thwet(i).x << " " << Thwet(i).y << " " << Thwet(i).label << endl;
   95 :         }
   96 :     }
   97 :
   98 :     for (int i = 0; i < Thwet.nt; i++){
   99 :         wf << Thwet[i][0] + 1 << " " << Thwet[i][1]  + 1 << " " << Thwet[i][2]  + 1 << " " << Thwet[i].label <<
È™ßt±Ë?endl;
  100 :     }
  101 :
  102 :     for(int i = 0; i < Thwet.nbe; i++){
  103 :         wf << Thwet.be(i)[0] + 1 << " " << Thwet.be(i)[1] + 1 << " " << Thwet.be(i).label <<  endl;
  104 :     }
  105 :
  106 :     wf.flush;
  107 :
  108 :     Thwet = readmesh(foldername + "Thwet.msh");
  109 :     // medit("Thwet", Thwet);
  110 :
  111 :     fespace Xhwet(Thwet, P1);
  112 :     Xhwet uwx, uwy, vx, vy;
  113 :     Xhwet uxold = 0.5, uyold = 0;
  114 :     Xhwet etawet, Hwet;
  115 :
  116 :     for(int i = 0; i < Thwet.nv; i++){
  117 :         // cout << "i = " << i + 2 << ": ";
  118 :         int it = Th(Thwet(i).x, Thwet(i).y).nuTriangle;
  119 :         for (int j = 0; j < 3; j++){
  120 :             if (Thwet(i).x == Th[it][j].x && Thwet(i).y == Th[it][j].y){
  121 :                 // cout.fixed << Th[it][j] + 2 << " => " << Th[it][j].x << " " << Th[it][j].y << endl;
  122 :                 if (t > dt){
  123 :                     uxold[][i] = ux[][Th[it][j]];
  124 :                     uyold[][i] = uy[][Th[it][j]];
  125 :                 }
  126 :                 Hwet[][i] = H[][Th[it][j]];
  127 :                 etawet[][i] = H[][Th[it][j]] + zh[][Th[it][j]];
  128 :                 break;
  129 :             }
  130 :         }
  131 :     }
  132 :     ux = 0; uy = 0; // reset
  133 :
  134 :     // Xhwet eta = H + zh;
  135 :     // Xhwet uUB = BoundData(0);
  136 :     // cout << uUB[] << endl;
  137 :     solve NavierStokes([uwx, uwy], [vx, vy], solver = Crout) =
  138 :         int2d(Thwet)((uwx * vx + uwy * vy) / dt)
  139 :         - int2d(Thwet)(
  140 :               convect([uxold, uyold], -dt, uxold) * vx / dt
  141 :             + convect([uxold, uyold], -dt, uyold) * vy / dt
  142 :         )
  143 :         + int2d(Thwet)(g * Grad(etawet)    [dx(etawet), dy(etawet)] ' * [vx, vy])
  144 :         // - int2d(Thwet)(g * eta * Div(vx, vy))
  145 :         - int2d(Thwet)(nu / Hwet * [vx, vy]' * Grad2(uwx, uwy)      [[dx(uwx), dy(uwx)], [dx( uwy), dy( uwy)]]
* Grad(Hwet)    [dx(Hwet), dy(Hwet)]  - nu * Grad1(uwx, uwy)      [dx(uwx), dy(uwx), dx( uwy), dy( uwy)] ' * Grad1(vx, vÈ™ßt±Ë?y)      [dx(vx), dy(vx), dx( vy), dy( vy)] )
  146 :         + int2d(Thwet)((tau * 1/Hwet^(4/3) * (uxold * uxold + uyold * uyold)^(0.5)) * (uwx * vx + uwy * vy))
  147 :         + on(2, uwx = BoundData(0), uwy = 0) + on(1, uwx = 0, uwy = 0);
  148 :
  149 :
  150 :     for(int i = 0; i < Thwet.nv; i++){
  151 :         int it = Th(Thwet(i).x, Thwet(i).y).nuTriangle;
  152 :         for (int j = 0; j < 3; j++){
  153 :             if (Thwet(i).x == Th[it][j].x && Thwet(i).y == Th[it][j].y){
  154 :                 ux[][Th[it][j]] = uwx[][i];
  155 :                 uy[][Th[it][j]] = uwy[][i];
  156 :                 break;
  157 :             }
  158 :         }
  159 :     }
  160 :     Hold = H;
  161 :     // plot(H, fill = 1, value = 1);
  162 :     plot([ux, uy], fill = 1, value = 1);
  163 :     // medit("Th", Th, [ux, uy]);
  164 :
  165 :     savesol(foldername + "ThH." + string(cnt) + ".sol", Th, H);
  166 :         savemesh(Th, foldername + "ThH." + string(cnt)+".mesh");
  167 :     savesol(foldername + "ThU." + string(cnt) + ".sol", Th, [ux, uy]);
  168 :         savemesh(Th, foldername + "ThU." + string(cnt)+".mesh");
  169 :     cnt += 1;
  170 : }
  171 : savemesh(Th, foldername + "ThH.mesh");
  172 : savemesh(Th, foldername + "ThU.mesh"); sizestack + 1024 =12928  ( 11904 )
 
  --  mesh:  Nb of Triangles =  12657, Nb of Vertices 6718
t: 0.01
  -- Solve :
          min -8.17135  max 25.4135
  --  mesh:  Nb of Triangles =   7956, Nb of Vertices 4684
 kk 2 3 :   -- Solve :
          min -2.39566e-025  max 0.734635
          min -0.029232  max 0.0285035
  number of required edges : 0
 write geo in result3/ThH.0.mesh.gmsh
  number of required edges : 0
 write geo in result3/ThU.0.mesh.gmsh
t: 0.02
  -- Solve :
          min -8.17135  max 25.4131
  --  mesh:  Nb of Triangles =   7956, Nb of Vertices 4684
 kk 2 3 :   -- Solve :
          min -2.40468e-025  max 0.744326
          min -0.0584635  max 0.0570064
  number of required edges : 0
 write geo in result3/ThH.1.mesh.gmsh
  number of required edges : 0
 write geo in result3/ThU.1.mesh.gmsh
t: 0.03
  -- Solve :
          min -8.17135  max 25.4127
  --  mesh:  Nb of Triangles =   7956, Nb of Vertices 4684
 kk 2 3 :   -- Solve :
          min -2.4137e-025  max 0.754017
          min -0.0876947  max 0.0855086
  number of required edges : 0
 write geo in result3/ThH.2.mesh.gmsh
  number of required edges : 0
 write geo in result3/ThU.2.mesh.gmsh
t: 0.04
  -- Solve :
          min -8.17135  max 25.4124
  --  mesh:  Nb of Triangles =   7956, Nb of Vertices 4684
 kk 2 3 :   -- Solve :
          min -2.42272e-025  max 0.763707
          min -0.116925  max 0.11401
  number of required edges : 0
 write geo in result3/ThH.3.mesh.gmsh
  number of required edges : 0
 write geo in result3/ThU.3.mesh.gmsh
t: 0.05
  -- Solve :
          min -8.17135  max 25.4121
  --  mesh:  Nb of Triangles =   7956, Nb of Vertices 4684
 kk 2 3 :   -- Solve :
          min -2.43174e-025  max 0.773396
          min -0.146156  max 0.142511
  number of required edges : 0
 write geo in result3/ThH.4.mesh.gmsh
  number of required edges : 0
 write geo in result3/ThU.4.mesh.gmsh
t: 0.06
  -- Solve :
          min -8.17135  max 25.4124
  --  mesh:  Nb of Triangles =   7956, Nb of Vertices 4684
 kk 2 3 :   -- Solve :
          min -2.44076e-025  max 0.783085
          min -0.175386  max 0.171011
  number of required edges : 0
 write geo in result3/ThH.5.mesh.gmsh
  number of required edges : 0
 write geo in result3/ThU.5.mesh.gmsh
t: 0.07
  -- Solve :
          min -8.17135  max 25.4135
 try getConsole D:\Study\Projects\XNM\code\XNM3.edp
