 
D:\Study\Projects\XNM\code>XNM4.edp
 
D:\Study\Projects\XNM\code>-- FreeFem++ v  3.610001 (date jeu. 12 juil. 2018 15:05:23)
 Load: lg_fem lg_mesh lg_mesh3 eigenvalue
    1 : load "medit"(load: loadLibary C:\Program Files (x86)\FreeFem++\\.\medit = 0)
    2 :
    3 : // load mesh
    4 : string path = "data/";
    5 : string filemesh = "Th3";
    6 : mesh Th = readmesh(path + filemesh + ".msh");
    7 : //medit("Th", Th);
    8 :
    9 : int NoVMesh; // Number of Vertices Mesh
   10 : int[int] neighbor2; // manually
   11 : if (filemesh == "Th1"){
   12 :     NoVMesh = 503;
   13 :     neighbor2 = [498, 494, 495, 497, 501];
   14 : }else if (filemesh == "Th2"){
   15 :     NoVMesh = 1787;
   16 :     neighbor2 = [2, 9, 18, 7, 21, 22, 14, 5];
   17 : }else{
   18 :     NoVMesh = 6724;
   19 :     neighbor2 = [6717, 6718, 6714, 6703, 6698, 6681, 6677, 6676, 6675, 6674, 6673, 6687, 6686, 6704, 6715, 6721];
   20 : }
   21 : //cout << neighbor2 << endl;
   22 :
   23 :
   24 : real[int, int] hz(NoVMesh, 4);
   25 : ifstream filemeshZ(path + filemesh + "CoZ.mesh");
   26 : filemeshZ >> hz;
   27 :
   28 : real[string] mapz;
   29 : for (int i = 0; i < hz.n; i++){
   30 :     mapz[string(hz(i, 0)) + " " + string(hz(i, 1))] = hz(i, 2);
   31 : }
   32 :
   33 : func real[int] FillZ(real[int] mat){
   34 :     for (int i = 0; i < Th.nv; i++){
   35 :         mat(i) = mapz[string(Th(i).x) + " " + string(Th(i).y)];
   36 :     }
   37 :     return mat;
   38 : }
   39 :
   40 : real[int, int] data(503, 4);
   41 : ifstream filedata(path + "SLMIKE21-4.txt");
   42 : filedata >> data;
   43 : //cout << data << endl;
   44 :
   45 : func real[int] InterpolationData(real t){
   46 :     // t: time (unit: second)
   47 :     real T = 3600;
   48 :     int n = t /  T;
   49 :     real delt = t / T - n;
   50 :     real[int] res(4);
   51 :     res(0) = data(n, 0) * delt + data(n + 1, 0) * (1 - delt);
   52 :     res(1) = data(n, 1) * delt + data(n + 1, 1) * (1 - delt);
   53 :     res(2) = data(n, 2) * delt + data(n + 1, 2) * (1 - delt);
   54 :     res(3) = data(n, 3) * delt + data(n + 1, 3) * (1 - delt);
   55 :     return res;
   56 : }
   57 :
   58 : func real FuncOfH(real h){
   59 :     //return 1;
   60 :     return h;
   61 : }
   62 :
   63 : func real FindParameterK(real Q, real[int] &h, real[int] &l){
   64 :     real sumArea = 0;
   65 :     for (int i = 0; i < h.n; i++){
   66 :         //cout << h(i) * l(i) << " " ;
   67 :         sumArea += FuncOfH(h(i)) * h(i) * l(i);
   68 :     }
   69 :     //cout << endl << sumArea <<" " << Q  << " " << Q/sumArea << endl;
   70 :     return Q / sumArea;
   71 : }
   72 :
   73 :
   74 : real dt = 0.01, nu = 2.67 * 1e-4, g = 9.81, rho = 100, n = 0.025, T = 9999999; //nu = 2.67 * 1e-4
   75 : real tau =  g * n * n;
   76 :
   77 : fespace Xh(Th, P1);
   78 : Xh u1, u2, v1, v2;
   79 : Xh u1old = 0.5, u2old = 0.5, eta, H, phi;
   80 : Xh z;
 *** Warning  The identifier z hide a Global identifier
 z[] = FillZ(z[]);
   81 : //cout << z[] << endl;
   82 :
   83 :
   84 : macro Grad(u) [dx(u), dy(u)]  )   [dx(u), dy(u)] //
   85 : macro Grad1(u1, u2) [dx(u1), dy(u1), dx(u2), dy(u2)]  )   [dx(u1), dy(u1), dx(u2), dy(u2)] //
   86 : macro Grad2(u1, u2) [[dx(u1), dy(u1)], [dx(u2), dy(u2)]]  )   [[dx(u1), dy(u1)], [dx(u2), dy(u2)]] //
   87 : macro Div(u1, u2) (dx(u1) + dy(u2))  )   (dx(u1) + dy(u2)) //
   88 :
   89 : //declare NS problem
   90 : real uUB = 1;
   91 : problem NavierStokes([u1, u2], [v1, v2], solver = Crout) =
   92 :     int2d(Th)((u1 * v1 + u2 * v2) / dt)
   93 :     - int2d(Th)(
   94 :         convect([u1old, u2old], -dt, u1old) * v1 / dt
   95 :         + convect([u1old, u2old], -dt, u2old) * v2 / dt
   96 :     )
   97 :     + int2d(Th)(g * Grad(eta)    [dx(eta), dy(eta)] ' * [v1, v2])
   98 :     - int2d(Th)(nu / H * Grad(H)    [dx(H), dy(H)] ' * Grad2(u1, u2)      [[dx(u1), dy(u1)], [dx( u2), dy( u2)]]  * [v1, v2] - nu * Grad1(u1, u2)      [dx(u1), dy(u1), dx(
u2), dy( u2)] ' * Grad1(v1, v2)      [dx(v1), dy(v1), dx( v2), dy( v2)] )
   99 :     + int2d(Th)((tau * H^(-4.0/3) * (u1old * u1old + u2old * u2old)^(0.5)) * (u1*
v1 + u2 * v2))
  100 :     + on(2, u1 = uUB, u2 = 0) + on(1, u1 = 0, u2 = 0);
  101 :
  102 : Xh HOld = 9 - z;
  103 : real Hbond2 = 9;
  104 : real etaUB = 1, etaUB1 = 1, etaUB2 = 1;
  105 : problem TransportEquation(H, phi) =
  106 :     int2d(Th)(H * phi / dt)
  107 :     //- int2d(Th)(convect([u1,u2], -dt, HOld) * phi / dt) + int2d(Th)(H * Div(u1,
u2) * phi)
  108 :     - int2d(Th)(HOld * phi / dt) + int2d(Th)(Grad(H)    [dx(H), dy(H)] ' * [u1, u2] * phi + H * Div(u1, u2)     (dx(u1) + dy( u2))  * phi)
  109 :     + on(2, H = etaUB) + on(1, H = 0) + on(3, H = etaUB1) + on(4, H = etaUB2);
  110 :
  111 :
  112 : //initial
  113 : int nbe2 = 0; // number of boundary element
  114 : int nlabel = 2;
  115 : for(int i = 0; i < Th.nbe; i++){
  116 :     if(Th.be(i)[0].label == nlabel){
  117 :         if(Th.be(i)[1].label == nlabel){
  118 :             nbe2 += 1;
  119 :         }
  120 :     }
  121 : }
  122 :
  123 : int[int, int] points2(nbe2, 2);
  124 : real[int] leng2(nbe2);
  125 : int j = 0;
  126 : for(int i = 0; i < Th.nbe; i++){
  127 :     if(Th.be(i)[0].label == nlabel){
  128 :         if(Th.be(i)[1].label == nlabel){
  129 :             leng2(j) = sqrt((Th.be(i)[0].x - Th.be(i)[1].x)^2 + (Th.be(i)[0].y - Th.be(i)[1].y)^2);
  130 :             points2(j, 0) = Th.be(i)[0];
  131 :             points2(j, 1) = Th.be(i)[1];
  132 :             j += 1;
  133 :         }
  134 :     }
  135 : }
  136 : //cout << nbe2 << endl;
  137 : //cout << points2 << endl;
  138 : //cout << leng2 << endl;
  139 : //cout << Th.hmax << endl;
  140 : int ii = 0;
  141 : real[int] h(nbe2);
  142 : real eps = 1e-6;
  143 : ofstream writefile("velocity.txt");
  144 : string foldername = "result4/";
  145 : for(real t = dt; t < T; t += dt){
  146 :     cout << "t: " << t << endl;
  147 :     real[int] QHH = InterpolationData(t);
  148 :     etaUB = QHH(1);
  149 :     etaUB1 = QHH(2);
  150 :     etaUB2 = QHH(3);
  151 :     Xh uOnBoundary2 = 0;
  152 :     cout << "HOld: "<< HOld[].min << " +-+ " << HOld[].max << endl;
  153 :     for(int it = 0; it < Th.nv; it++){
  154 :         if(HOld[][it] < eps){
  155 :             HOld[][it] = eps;
  156 :         }
  157 :     }
  158 :     TransportEquation;
  159 :     cout << "HOld: "<< HOld[].min << " +-+ " << HOld[].max << endl;
  160 :     for(int it = 0; it < Th.nv; it++){
  161 :         if(H[][it] < eps){
  162 :             H[][it] = eps;
  163 :         }
  164 :     }
  165 :     //h_i = (H_i + H_i+1)/2....here
  166 :     for(int i = 0; i < nbe2; i++){
  167 :         h(i) = (H[](points2(i, 0)) + H[](points2(i, 1))) / 2;
  168 :     }
  169 :
  170 :     real k = FindParameterK(QHH(0), h, leng2);
  171 :     //cout << "h: " << h << " k: "<< k << " Q: " << QHH(0) << endl;
  172 :     for(int i = 0; i < h.n; i++){
  173 :         uOnBoundary2[](points2(i, 0)) =  k * FuncOfH(h(i));
  174 :         uOnBoundary2[](points2(i, 1)) =  k * FuncOfH(h(i));
  175 :     }
  176 :
  177 :     eta = H + z;
  178 :     uUB = uOnBoundary2;
  179 :     NavierStokes;
  180 :     u1old = u1; u2old = u2;
  181 :     HOld = H;
  182 :     // Hbond2 = 0;
  183 :     // for(int it = 0; it < neighbor2.n; it++){
  184 :     //     Hbond2 += HOld[][neighbor2(it) - 1];
  185 :     // }
  186 :     // Hbond2 = Hbond2 / neighbor2.n;
  187 :     //plot([u1, u2], fill = 1, value = 1);
  188 :     plot(H, fill = 1, value = 1);
  189 :     // streamline
  190 :     savesol(foldername + "Th." + string(ii) + ".sol", Th, H); //[u1, u2]
  191 :         savemesh(Th, foldername + "Th." + string(ii)+".mesh");
  192 :     ii += 1;
  193 :     if (ii > 10000){
  194 :         break;
  195 :     }
  196 :
  197 :         // Xh psi,phi;
  198 :     // solve streamlines(psi,phi) =
  199 :     //     int2d(Th)( dx(psi)*dx(phi) + dy(psi)*dy(phi))
  200 :     //     + int2d(Th)(-phi * (dy(u1)-dx(u2))) + on(1, psi = 0)+on(2, 3, 4, psi=0);
  201 :     // plot(psi, fill=true, value = 1);
  202 :
  203 : }
  204 : savemesh(Th, foldername + "Th.mesh");
  205 :  sizestack + 1024 =8968  ( 7944 )
 
  --  mesh:  Nb of Triangles =  12673, Nb of Vertices 6724
t: 0.01
HOld: -8.19413 +-+ 25.4911
 Warning: -- Your set of boundary condition is incompatible with the mesh label.
 Warning: -- Your set of boundary condition is incompatible with the mesh label.
 Warning: -- Your set of boundary condition is incompatible with the mesh label.
  -- Solve :
          min -6.02811  max 25.7202
HOld: 1e-006 +-+ 25.4911
  current line = 178
Exec error : Try to get unset x,y, ...
   -- number :1
Exec error : Try to get unset x,y, ...
   -- number :1
 err code 7 ,  mpirank 0
 try getConsole D:\Study\Projects\XNM\code\XNM4.edp
