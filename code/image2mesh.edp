load "ppm2rnm" load "isoline" load "medit"
string image = "../realdata/image.pgm";
// 580 -> 604 (=24) and 2323 -> 2335 (=12)
real AreaImage = (24 + 2 * 0.2) * (12 + 2 * 0.2); 
real [int , int] Curves(3, 1);
int [int] be(1) ;
int nc;
{ 
	// build the curve file xy. txt ...
	real [int, int] ff1(image) ; // read image and set to an rect . array
	// remark (0 ,0) is the upper , left corner .
	int nx = ff1.n , ny = ff1.m ;
	// build a cartesain mesh such that the origne is qt the right place .
	mesh Th = square(nx - 1, ny - 1, [(nx - 1)*x, (ny - 1)*(1 - y) ]) ;
	// warning the numbering is of the vertices (x,y) is
	// given by $ i = x/nx + nx* y/ny $
	fespace Vh(Th, P1);
	Vh f1 ;
	f1[] = ff1 ; // transforme array in finite element function .
	real vmax = f1[].max;
	real vmin = f1[].min;
	real vm = (vmin + vmax)/2;
	verbosity = 3;
	/*
	Usage of isoline
	the named parameter :
	iso =0.25 // value of iso
	close =1 , // to force to have closing curve ...
	beginend =be , // begin and end of curve
	smoothing =.01 , // nb of smoothing process = size ^ ratio * 0.01
	where size is the size of the curve ...
	ratio =0.5
	file =" filename "
	ouptut :
	xx , yy the array of point of the iso value
	a closed curve number n is
	in fortran notation the point of the curve are:
	(xx[i],yy[i] , i = i0 , i1)
	with : i0=be [2*n] , i1=be [2*n +1];
	*/
	nc = isoline(Th, f1, Curves, iso = vm, close = false, beginend = be, smoothing = .005 , ratio = 0.1);
	verbosity = 1;
}
int ic0 = be(0), ic1 = be(1) - 1;
//plot([Curves (0, ic0:ic1 ), Curves (1, ic0:ic1)], wait=1);
// end smoothing the curve ....
macro GG(i)
border G#i(t = 0, 1){
	P = Curve(Curves, be(2 * i), be(2 * i + 1) - 1, t);
	label = i + 1 + (abs(x - 7.56) < 0.1) + 2 * (abs(y - 7.59) < 0.1) + 3 * (abs(x - 960.4) < 0.1);
}
real lg#i = Curves(2, be(2 * i + 1) - 1); //
GG(0) GG(1) //GG(2) //GG(3)// number of closing curve
real hh = -20;
//plot(G0(lg0/hh) + G1(lg1/hh));
// + (abs(x - 7.56) < 0.05) + 2 * (abs(y - 7.59) < 0.03) + 3 * (abs(x - 960.4) < 0.05);
func bord = G0(lg0/hh);
mesh Th = buildmesh(bord);
//plot(Th, wait = 1);

func bord1 = G1(-lg1/hh);
mesh Th1 = buildmesh(bord1);
//plot(Th1, wait = 1);

real scale = sqrt(AreaImage / Th1.area);
cout << "Scale: " << scale << endl;
Th = movemesh(Th, [x * scale * 1000 + 580000 - 200, y * scale * 1000 + 2323000 - 200]);

func newlabel = (label == 1) ? 2 : 0;
Th = change(Th, flabel = newlabel);

//plot(Th, wait = true);
//medit("test", Th);
savemesh (Th ,"Th1.mesh");

/* 
func bord = G0(lg0/hh);//+G1(lg1/hh)+G2(lg2/hh)+G3(lg3/hh);
//plot (bord , wait =1) ;
mesh Th = buildmesh(bord);
real scale = sqrt(AreaImage / Th.area);
cout << "Scale: " << scale << endl;
Th = movemesh(Th, [x * scale * 1000 + 580000 - 200, y * scale * 1000 + 2323000 - 200]);
//Th = adaptmesh (Th, 9, IsMetric=1, nbvx=1e6);
//plot (Th , wait = 1);
medit("test", Th);
*/
//
/* 
fespace Vh(Th,P1);
Vh u = 0;
for(int i = 0; i < Th.nv; i++){
    if(Th(i).label == 1){
        //ux[][i]=Th(i).x;
        //uy[][i]=Th(i).y;
        u[][i] = 1;
    }
}
mesh Sh = trunc(Th, abs(u) < 1.e-10, split = 2, label = 0);
plot(Sh, wait = 1);
//Sh = adaptmesh(Sh, 9, IsMetric=1, nbvx=1e6);
Th = Th + Sh;

//

plot (Th , wait =1) ;
//medit("test", Th);
//savemesh (Th ,"Th.mesh") ;
*/