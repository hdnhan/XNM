load "medit"

string path = "data/";
string filemesh = "Th2";
mesh Th = readmesh(path + filemesh + ".msh");
//medit("Th", Th);

int NoVMesh; // Number of Vertices Mesh
if (filemesh == "Th1"){
    NoVMesh = 503;
}else if (filemesh == "Th2"){
    NoVMesh = 1787;
}else{
    NoVMesh = 6724;
}

real[int, int] hz(NoVMesh, 4);
ifstream filemeshZ(path + filemesh + "CoZ.mesh");
filemeshZ >> hz;

real[string] mapz;
for (int i = 0; i < hz.n; i++){
    mapz[string(hz(i, 0)) + " " + string(hz(i, 1))] = hz(i, 2);
}

func real[int] FillZ(real[int] mat){
    for (int i = 0; i < Th.nv; i++){
        mat(i) = mapz[string(Th(i).x) + " " + string(Th(i).y)];
    }
    return mat;
}

real[int, int] data(503, 4);
ifstream filedata(path + "SLMIKE21-3.txt");
filedata >> data;

func real[int] InterpolationData(real t){
    // t: time (unit: second)
    real T = 3600;
    int n = t /  T;
    real delt = t / T - n;
    real[int] res(4);
    res(0) = data(n, 0) * delt + data(n + 1, 0) * (1 - delt);
    res(1) = data(n, 1) * delt + data(n + 1, 1) * (1 - delt);
    res(2) = data(n, 2) * delt + data(n + 1, 2) * (1 - delt);
    res(3) = data(n, 3) * delt + data(n + 1, 3) * (1 - delt);
    return res; 
}

real dt = 1e-2, nu = 2.67 * 1e-4, g = 9.81, rho = 1000, n = 0.025, T = 9999999;
real tau =  g * n * n;
 
fespace Xh(Th, P1);
Xh ux, uy, vx, vy;
Xh uxold = 0.5, uyold = 0, eta, H, phi;
Xh zh; zh[] = FillZ(zh[]);

macro Grad(u) [dx(u), dy(u)] //
macro Grad1(ux, uy) [dx(ux), dy(ux), dx(uy), dy(uy)] //
macro Grad2(ux, uy) [[dx(ux), dy(ux)], [dx(uy), dy(uy)]] //
macro Div(ux, uy) (dx(ux) + dy(uy)) //


Xh uUB;

problem NavierStokes([ux, uy], [vx, vy], solver = Crout) = 
    int2d(Th)((ux * vx + uy * vy) / dt)
    - int2d(Th)(
          convect([uxold, uyold], -dt, uxold) * vx / dt 
        + convect([uxold, uyold], -dt, uyold) * vy / dt
    )
    //+ int2d(Th)(g * Grad(eta)' * [vx, vy])
    - int2d(Th)(g * eta * Div(vx, vy))
    - int2d(Th)(nu / H * [vx, vy]' * Grad2(ux, uy) * Grad(H) - nu * Grad1(ux, uy)' * Grad1(vx, vy))
    + int2d(Th)((tau * 1/H^(4/3) * (uxold * uxold + uyold * uyold)^(0.5)) * (ux * vx + uy * vy))
    + on(2, ux = uUB, uy = 0) + on(1, ux = 0, uy = 0);

Xh Hold = 9 - zh;
Xh etaUB, etaUB1, etaUB2;
problem TransportEquation(H, phi) = 
    int2d(Th)(H * phi / dt) - int2d(Th)(Hold * phi / dt) 
    //+ int2d(Th)(Grad(H)' * [ux, uy] * phi + H * Div(ux, uy) * phi)
    - int2d(Th)(H * [ux, uy]' * Grad(phi))
    + on(2, H = etaUB - zh) + on(1, H = 0);// + on(3, H = etaUB1 - zh) + on(4, H = etaUB2 - zh);



int cnt = 0;
real eps = 1e-6;
string foldername = "result4/";
for(real t = dt; t < T; t += dt){
    cout << "t: " << t << endl;
    real[int] BoundData = InterpolationData(t);
    etaUB = BoundData(1); // Th4
    etaUB1 = BoundData(2);
    etaUB2 = BoundData(3);
    Xh uOnBoundary2 = 0;
    TransportEquation;
    for(int it = 0; it < Th.nv; it++){
        if(abs(H[][it]) < eps){
            H[][it] = eps;
        }
    }
      
    eta = H + zh;
    uUB = BoundData(0);
    cout << "u from file: "  << BoundData(0) << endl;
    //cout << "min uUB: " << uUB[].min << " " << uUB[].max << endl;
    NavierStokes;
    for(int it = 0; it < Th.nv; it++){
        if(H[][it] < 0){
            ux[][it] = 0;
            uy[][it] = 0;
        }
    }
    uxold = ux; uyold = uy;
    Hold = H;

    //plot([ux, uy], fill = 1, value = 1);
    plot(H, fill = 1, value = 1);
    
    savesol(foldername + "ThH." + string(cnt) + ".sol", Th, H);
	savemesh(Th, foldername + "ThH." + string(cnt)+".mesh");
    savesol(foldername + "ThU." + string(cnt) + ".sol", Th, H);
	savemesh(Th, foldername + "ThU." + string(cnt)+".mesh");
    cnt += 1;
}
savemesh(Th, foldername + "ThU.mesh");
savemesh(Th, foldername + "ThH.mesh");
