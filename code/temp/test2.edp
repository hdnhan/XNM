string filemesh = "Th2";
mesh Th = readmesh(filemesh + ".mesh");

load "medit"
//medit(filemesh, Th);

int MeshVertices;
if (filemesh == "Th1")
    MeshVertices = 503;
else if (filemesh == "Th2")
    MeshVertices = 1787;
else
    MeshVertices = 6724;

real[int, int] hz(MeshVertices, 4);
ifstream filemeshZ(filemesh + "CoZ.mesh");
filemeshZ >> hz;

real[string] mapz;
for (int i = 0; i < hz.n; i++){
    mapz[string(hz(i, 0)) + " " + string(hz(i, 1))] = hz(i, 2);
}

func real[int] FillZ(real[int] mat){
    for (int i = 0; i < Th.nv; i++){
        mat(i) = mapz[string(Th(i).x) + " " + string(Th(i).y)];
    }
    return mat;
}

real[int, int] data(503, 3);
ifstream filedata("data.txt");
filedata >> data;
//cout << data << endl;

func real[int] InterpolationData(real t){
    // t: time (unit: second)
    real T = 3600;
    int n = t /  T;
    real delt = t - n * T;
    real[int] res(3);
    res(0) = data(n, 0) * delt + data(n + 1, 0) * (T - delt);
    res(1) = data(n, 1) * delt + data(n + 1, 1) * (T - delt);
    res(2) = data(n, 2) * delt + data(n + 1, 2) * (T - delt);
    return res; 
}

func real FuncOfH(real h){
    return 1;
    //return h;
}

func real FindParameterK(real Q, real[int] &h){
    real[int] l(h.n);
    l = Th.hmax;
    real sumup = 0;
    for (int i = 0; i < h.n; i++){
        sumup += FuncOfH(h(i)) * h(i) * l(i);
    }
    return Q / sumup;
}



real dt = 1, nu = 2.67 * 1e-4, g = 9.81, rho = 100, n = 0.025, T = 9999999; //nu = 2.67 * 1e-4
//real[int] taub = [0 , 0];
real tau =  g * n * n;
//macro NormVe(u1, u2) (sqrt(u1 * u1 + u2 * u2)) //
 
fespace Xh(Th, P1);
Xh u1, u2, v1, v2;
Xh u1old = 0.5, u2old = 0.5, eta, H, phi;
Xh z; z[] = FillZ(z[]);
//cout << z[] << endl;
 

macro Grad(u) [dx(u), dy(u)] //
macro Grad1(u1, u2) [dx(u1), dy(u1), dx(u2), dy(u2)] //
macro Grad2(u1, u2) [[dx(u1), dy(u1)], [dx(u2), dy(u2)]] //
macro Div(u1, u2) (dx(u1) + dy(u2)) //

//declare NS problem
Xh u1y = 1; H = 20 - z;
problem NavierStokes(u1, u2, v1, v2, solver = Crout) = 
    int2d(Th)((u1 * v1 + u2 * v2) / dt)
    - int2d(Th)(
        convect([u1old, u2old], -dt, u1old) * v1 / dt + 
        convect([u1old, u2old], -dt, u2old) * v2 / dt
    )
    + int2d(Th)(g * Grad(eta)' * [v1, v2])
    - int2d(Th)(nu / H * Grad(H)' * Grad2(u1, u2) * [v1, v2] - nu * Grad1(u1, u2)' * Grad1(v1, v2))
    //+ int2d(Th)(tau /(H^(4.0/3)) * (u1old * u1old + u2old * u2old)^(0.5) * (u1* v1 + u2 * v2))
    + int2d(Th)((tau * H^(-4.0/3) * (u1old * u1old + u2old * u2old)^(0.5)) * (u1* v1 + u2 * v2))
    + on(2, u1 = u1y, u2 = 0) + on(1, u1 = 0, u2 = 0);

Xh HOld;
HOld = 9 - z;
real H3 = 0, H4 = 0;
problem TransportEquation(H, phi) = 
    int2d(Th)(H * phi / dt) - int2d(Th)(HOld * phi / dt) +
    int2d(Th)(Grad(H)' * [u1, u2] * phi + H * Div(u1, u2) * phi)
    + on(2, H = HOld) + on(1, H = 0);// + on(3, H = H3) + on(4, H = H4);


//initial
int nbe2 = 0; // number of boundary element
int nlabel = 2;
for(int i = 0; i < Th.nbe; i++){
    if(Th.be(i)[0].label == nlabel){
        if(Th.be(i)[1].label == nlabel){
            nbe2 += 1;
        }
    }
}

int[int, int] points2(nbe2, 2);
int j = 0;
for(int i = 0; i < Th.nbe; i++){
    if(Th.be(i)[0].label == nlabel){
        if(Th.be(i)[1].label == nlabel){
            points2(j, 0) = Th.be(i)[0];
            points2(j, 1) = Th.be(i)[1];
            j += 1;
        }
    }
}
//cout << nbe2 << endl;
//cout << points2 << endl;

ofstream writefile("velocity.txt");
for(real t = dt; t < T; t += dt){
    cout << "t: " << t << endl;
    
    NavierStokes;
    u1old = u1; u2old = u2;
    plot([u1, u2], value = 1);
    // streamline
	//Xh psi,phi;
    //solve streamlines(psi,phi) = 
    //    int2d(Th)( dx(psi)*dx(phi) + dy(psi)*dy(phi)) 
    //    + int2d(Th)(-phi * (dy(u1)-dx(u2))) + on(1, psi = 0)+on(2, 3, 4, psi=0);
	
	//vort=dy(u1) - dx(u2);
    //plot( vort, dim=2d, fill=0, wait=0);
    //plot(psi, fill=true, value = 1);
    
}
